# Source: http://stats.stackexchange.com/questions/33078/data-has-two-trends-how-to-extract-independent-trendlines/34287

import numpy as np
import matplotlib.pyplot as plt
from model import LeastSquaresMixture


def log_likelihood(x, y, w_k, beta):
    tx = np.array([1, x])
    return - 0.5 * (np.log(2 * np.pi) - np.log(beta) + beta * (y - np.dot(w_k, tx))**2)


def posterior(x, y, w_k, pi_k, beta):
    likelihood = np.exp(log_likelihood(x, y, w_k, beta))
    return pi_k * likelihood


def normal_pdf(x, mu, sigma2):
    return 1 / np.sqrt(2*np.pi*sigma2) * np.exp(-0.5 * (x - mu) **2 / sigma2)


# Generate some random data
N = 100
X = np.random.rand(N, 1)
tX = np.ones((N, 2))
tX[:, 1] = X[:, 0]

w = np.random.rand(2, 2)
y = np.zeros(N)

n = int(np.random.rand(1, 1) * N)
y[:n] = np.dot(tX[:n, :], w[0, :]) + np.random.normal(size=n) * .01
y[n:] = np.dot(tX[n:, :], w[1, :]) + np.random.normal(size=N - n) * .01

rx = np.ones((100, 2))
r = np.arange(0, 1, .01)
rx[:, 1] = r

# Plot the random dataset
plt.plot(tX[:, 1], y, '.b')
plt.plot(r, np.dot(rx, w[0, :]), ':k', linewidth=2)
plt.plot(r, np.dot(rx, w[1, :]), ':k', linewidth=2)

# Train the model
lsm = LeastSquaresMixture(X, np.expand_dims(y, axis=1), K=2)
lsm.train(beta=0.03, epsilon=1e-10, lam=0, iterations=100, random_restarts=100,  verbose=False)
print(lsm)

w1 = lsm.w[:2, 0]
w2 = lsm.w[:2, 1]
print(w1)
print(w2)
plt.plot(r, np.dot(rx, w1), '-r')
plt.plot(r, np.dot(rx, w2), '-g')

# New point to display
x_new = [0.9]
y_new = lsm.predict(x_new)

# x_red = plt.plot(x_new, y_new, 'rx', mew=4, ms=10)
# x_green = plt.plot(x_new, y_new, 'gx', mew=4, ms=10)
x_black = plt.plot(x_new, y_new, 'kx', mew=4, ms=10)

# likelihood_red = log_likelihood(x_new, y_hat, w1, beta)
# likelihood_green = log_likelihood(x_new, y_hat, w2, beta)
#
# posterior_red = posterior(x_new, y_hat, w1, pi1, beta)
# posterior_green = posterior(x_new, y_hat, w2, pi2, beta)
# print posterior_green, posterior_red
# normalization = posterior_red + posterior_green
# print normalization
# posterior_red /= normalization
# posterior_green /= normalization
# print posterior_red, posterior_green
#
# print "More likely to be generated by %s line" % ("red" if likelihood_red > likelihood_green else "green")
# print "New point at (%s, %s) is composed of %0.2f%% red and %0.2f%% green" % (x_new, y_hat, posterior_red, posterior_green)
#
plt.savefig('MLS.pdf')
